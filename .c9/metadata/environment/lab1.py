{"filter":false,"title":"lab1.py","tooltip":"/lab1.py","ace":{"folds":[],"scrolltop":474,"scrollleft":0,"selection":{"start":{"row":56,"column":42},"end":{"row":56,"column":65},"isBackwards":true},"options":{"guessTabSize":true,"useWrapMode":true,"wrapToView":true},"firstLineState":{"row":134,"state":"start","mode":"ace/mode/python"},"cleansed":true},"hash":"33ecc5489573606995ee26f7b9dda07baa4cde9e","changed":true,"value":"import numpy as np\nimport string\nimport random\nimport base64\n\ndef substitute_encrypt(message, key):\n    \"\"\"Encrypt message using character substitution. Key is a random permutation of the 26 letters\"\"\"\n    # map message to numerical array in range(0,26)\n    plain = [x - ord('a') for x in map(ord,message)]\n    # apply substitution according to key\n    cipher = [key[x] for x in plain]\n    # rewrite numerical array in uppercase letters\n    cryptogram = [chr(x+ord('A')) for x in cipher]\n    return ''.join(cryptogram)\n    \ndef substitute_decrypt(cryptogram, key):\n    \"\"\"Decrypt cryptogram using character substitution. Key is a random permutation of the 26 letters\"\"\"\n    # map cryptogram to numerical array in range(0,26)\n    cipher = [x - ord('A') for x in map(ord,cryptogram)]\n    # compute inverse permutation\n    rev_key = np.argsort(key)\n    # apply inverse substitution according to key\n    plain = [rev_key[x] for x in cipher]\n    # rewrite numerical array in lowercase letters\n    message = [chr(x+ord('a')) for x in plain]\n    return ''.join(message)\n\n\ndef Vigenere_encrypt(message, key):\n    \"\"\"Encrypt message using Vigenere algorithm. Key is a password.\"\"\"\n    # map message to numerical array in range(0,26)\n    plain = [x - ord('a') for x in map(ord,message)]\n    # map key (password) to numerical array in range(0,26)\n    keynum = [x - ord('a') for x in map(ord,key)]\n    # allocate empty array\n    cipher = [0] * len(plain)\n    i = 0\n    klen = len(key)\n    for k in keynum:\n        # substistute one character every klen characters according to key[i]\n        cipher[i::klen] = [(x + k) % 26 for x in plain[i::klen] ]\n        i = i + 1\n    # rewrite numerical array in uppercase letters\n    cryptogram = [chr(x+ord('A')) for x in cipher]\n    return ''.join(cryptogram)\n    \ndef Vigenere_decrypt(cryptogram, key):\n    \"\"\"Encrypt message using Vigenere algorithm. Key is a password.\"\"\"\n    # map cryptogram to numerical array in range(0,26)\n    cipher = [x - ord('A') for x in map(ord,cryptogram)]\n    # map key (password) to numerical array in range(0,26)\n    keynum = [x - ord('a') for x in map(ord,key)]\n    # allocate empty array\n    plain = [0] * len(cipher)\n    i = 0\n    klen = len(key)\n    for k in keynum:\n        # substistute one character every klen characters according to key[i]\n        plain[i::klen] = [(x - k) % 26 for x in cipher[i::klen] ]\n        i = i + 1\n    # rewrite numerical array in lowercase letters\n    message = [chr(x+ord('a')) for x in plain]\n    return ''.join(message)\n    \n\n\n\ndef monogram_ranking(cryptogram, topn=None):\n    \"\"\"Returns the topn most frequent monograms (letters) in cryptogram\"\"\"\n    # map letters to numerical values in range(0,26)\n    cipher = [x - ord('A') for x in map(ord,cryptogram)]\n    # compute histogram of letter values\n    freq = np.histogram(cipher, 26, (-0.5, 25.5))\n    # get sorted letters in decreasing order of their frequency\n    sorted_monograms = [(chr(x+ord('A')), freq[0][x]) for x in np.argsort(-freq[0])]\n    return sorted_monograms[0:topn]\n\n\ndef digram_to_number(t, i):\n    return 26*(ord(t[i]) - ord('A')) + ord(t[i+1]) - ord('A')\n    \ndef number_to_digram(x):\n    return ''.join([chr(x // 26 + ord('A')), chr(x % 26 + ord('A'))])\n\n\ndef digram_ranking(cryptogram, topn=None):\n    \"\"\"Returns the topn most frequent digrams (letter pairs) in cryptogram\"\"\"\n    # map digrams to numerical values in range(0,26*26)\n    digrams = [digram_to_number(cryptogram, i) for i in range(0,len(cryptogram)-1)]\n    # compute histogram of digram values\n    freq = np.histogram(digrams, 26*26, (-0.5, 26*26-0.5))\n    # get sorted digrams in decreasing order of their frequency\n    sorted_digrams = [(number_to_digram(x), freq[0][x]) for x in np.argsort(-freq[0])]\n    return sorted_digrams[0:topn]\n    \n    \ndef trigram_to_number(t, i):\n    return 26*26*(ord(t[i]) - ord('A')) + 26*(ord(t[i+1]) - ord('A')) + ord(t[i+2]) - ord('A')\n        \ndef number_to_trigram(x):\n    return ''.join([chr(x // (26*26) + ord('A')), chr((x % (26*26) // 26) + ord('A')), chr(x % 26 + ord('A'))])\n\ndef trigram_ranking(cryptogram, topn=None):\n    \"\"\"Returns the topn most frequent trigrams (letter triplets) in cryptogram\"\"\"\n    # map trigrams to numerical values in range(0,26*26*26)\n    trigrams = [trigram_to_number(cryptogram, i) for i in range(0,len(cryptogram)-2)]\n    # compute histogram of trigram values\n    freq = np.histogram(trigrams, 26*26*26, (-0.5, 26*26*26-0.5))\n    # get sorted trigrams in decreasing order of their frequency\n    sorted_trigrams = [(number_to_trigram(x), freq[0][x]) for x in np.argsort(-freq[0])]\n    return sorted_trigrams[0:topn]\n    \n\ndef crypto_freq(cryptogram):\n    \"\"\"Returns the relative frequencies of characters in  cryptogram\"\"\"\n    # map letters to numerical values in range(0,26)\n    cipher = [x - ord('A') for x in map(ord,cryptogram)]\n    # compute histogram of letter values\n    freq = np.histogram(cipher, 26, (-0.5, 25.5))\n    # return relative frequency\n    return freq[0] / len(cipher)\n    \n    \n    \ndef periodic_corr(x, y):\n    \"\"\"Periodic correlation, implemented using the FFT. x and y must be real sequences with the same length.\"\"\"\n    return np.fft.ifft(np.fft.fft(x) * np.fft.fft(y).conj()).real\n    \ndef key_len(cryptogram,length):\n    subsequence = cryptogram[0::length]\n    Q = crypto_freq(subsequence)\n    score = sum(np.square(Q))\n    return np.abs(score-0.065)<0.01\n    \ndef crack_key (cryptogram,keylen,P):\n    s=[]\n    key = []\n    for i in range(keylen):\n        s = []\n        n = 0\n        # Slice the cyphertext\n        s = cryptogram[i:len(cryptogram):keylen]\n        # Calculate the frequence of letters\n        Q = crypto_freq(s)\n        \n        # Select the key that fit the best with english language distribution\n        key.append(np.argmax(periodic_corr(Q,P)))\n\n    return key    \n    \ndef main():\n    # frequency of English letters in alphabetical order\n    english_letter_freqs = [0.085516907,\n    0.016047959,\n    0.031644354,\n    0.038711837,\n    0.120965225,\n    0.021815104,\n    0.020863354,\n    0.049557073,\n    0.073251186,\n    0.002197789,\n    0.008086975,\n    0.042064643,\n    0.025263217,\n    0.071721849,\n    0.074672654,\n    0.020661661,\n    0.001040245,\n    0.063327101,\n    0.067282031,\n    0.089381269,\n    0.026815809,\n    0.010593463,\n    0.018253619,\n    0.001913505,\n    0.017213606,\n    0.001137563]\n    \n    Dict_digram={'TH' : 2.71, 'EN' : 1.13, 'NG' : 0.89,\n    'HE' : 2.33, 'AT' : 1.12, 'AL' : 0.88,\n    'IN' : 2.03, 'ED' : 1.08, 'IT' : 0.88,\n    'ER' : 1.78, 'ND' : 1.07, 'AS' : 0.87,\n    'AN' : 1.61, 'TO' : 1.07, 'IS' : 0.86,\n    'RE' : 1.41, 'OR' : 1.06, 'HA' : 0.83,\n    'ES' : 1.32, 'EA' : 1.00, 'ET' : 0.76,\n    'ON' : 1.32, 'TI' : 0.99, 'SE' : 0.73,\n    'ST' : 1.25, 'AR' : 0.98, 'OU' : 0.72,\n    'NT' : 1.17, 'TE' : 0.98, 'OF' : 0.71}\n\n    Dict_trigram={'THE' : 1.81, 'ERE' : 0.31, 'HES' : 0.24,\n    'AND' : 0.73, 'TIO' : 0.31, 'VER' : 0.24,\n    'ING' : 0.72, 'TER' : 0.30, 'HIS' : 0.24,\n    'ENT' : 0.42, 'EST' : 0.28, 'OFT' : 0.22,\n    'ION' : 0.42, 'ERS' : 0.28, 'ITH' : 0.21,\n    'HER' : 0.36, 'ATI' : 0.26, 'FTH' : 0.21,\n    'FOR' : 0.34, 'HAT' : 0.26, 'STH' : 0.21,\n    'THA' : 0.33, 'ATE' : 0.25, 'OTH' : 0.21,\n    'NTH' : 0.33, 'ALL' : 0.25, 'RES' : 0.21,\n    'INT' : 0.32, 'ETH' : 0.24, 'ONT' : 0.20}\n\n#-----------------------------ES1------------------------------------------------------------    \n    with open(\"cryptogram01.txt\",\"r\") as text_file:\n        cryptogram = text_file.read()\n    with open(\"cryptogram02.txt\",\"r\") as text_file:\n        cryptogram2 = text_file.read()\n    with open(\"cryptogram03.txt\",\"r\") as text_file:\n        cryptogram3 = text_file.read()\n    print(cryptogram)\n    print(monogram_ranking(cryptogram, 5))\n    print(digram_ranking(cryptogram, 3))\n    print(trigram_ranking(cryptogram, 3))\n    \n    # you can write here your code for the lab and test it with \"python3 AISC_01.py\n    \n    # Sort monograms\n    \n    # monograms=monogram_ranking(cryptogram, 3)\n    guess01 = cryptogram\n    # ind =np.argpartition(english_letter_freqs,-3)[-3:]\n    # res = sorted(range(len(english_letter_freqs)), key = lambda sub: english_letter_freqs[sub], reverse=False)[-3:]\n    # Dict={}\n    # i=0\n    # for x in reversed(res):\n    #     Dict[ord(monograms[i][0])] = chr(x+ord('A'))\n    #     i+=1\n    # guess01 = cryptogram.translate(Dict)\n    # print(cryptogram)\n    # print(guess01)\n    \n    # Sort \n    #supponiamo che BYX sia THE\n    guess01 = cryptogram.replace('BYX', 'the')\n    guess01 = guess01.replace('BY', 'th')\n    guess01=guess01.replace('YX','he')\n    guess01 = guess01.replace('Y', 'h')\n    guess01=guess01.replace('X', 'e')\n    guess01=guess01.replace('B', 't')\n    \n    guess01=guess01.replace('T', 'a')\n    \n    #la consonoante piÃ¹ probabile era la n\n    guess01=guess01.replace('J', 'n')\n    \n    #abbiamo beccato Ahen quindi la W ci stava bene come A\n    guess01=guess01.replace('A', 'w')\n    \n    #abbiamo beccato weaOth quindi la O ci stava bene come L\n    guess01=guess01.replace('O', 'l')\n    \n    # whateZeW\n    guess01=guess01.replace('Z', 'v').replace('W', 'r')\n    \n    guess01=guess01.replace('V', 's')\n    \n    guess01=guess01.replace('G', 'p')\n    guess01=guess01.replace('R', 'o')\n    guess01=guess01.replace('D', 'u')\n    guess01=guess01.replace('H', 'y')\n    guess01=guess01.replace('F','d')\n    guess01=guess01.replace('L','f')\n    guess01=guess01.replace('U', 'b')\n    guess01=guess01.replace('N', 'i')\n    guess01=guess01.replace('I', 'c')\n    guess01=guess01.replace('M', 'g')\n    guess01=guess01.replace('S', 'm')\n    guess01=guess01.replace('P', 'k')\n    guess01=guess01.replace('E', 'x')\n\n    print(guess01)\n    '''\n    \n    '''\n#-----------------Es2--------------------------------------------------\n    length=1\n    while (not key_len(cryptogram2,length) and length < 25 ):\n        length +=1\n    print(length)\n    key_vig=crack_key(cryptogram2,length,english_letter_freqs)\n    \n    k=[]\n    for x in key_vig:\n        k.append(chr(x+ord('a')))\n    \n    print(k)\n    \n    listToStr = ''.join([str(elem) for elem in k])\n    print(listToStr)\n\n    print(Vigenere_decrypt(cryptogram2,listToStr.lower()))\n    \n# -------------------- --------------------\n    length=1\n    while (not key_len(cryptogram3,length) and length < 25 ):\n        length +=1\n    print(length)\n    \n    key_vig=crack_key(cryptogram3,length,english_letter_freqs)\n    \n    k=[]\n    for x in key_vig:\n        k.append(chr(x+ord('a')))\n    \n    print(k)\n    \n    listToStr = ''.join([str(elem) for elem in k])\n    print(listToStr)\n\n    #print(Vigenere_decrypt(cryptogram3,listToStr.lower()))\n    res = Vigenere_decrypt(cryptogram3,listToStr.lower())\n    print(res)\n    \n    \nif __name__ == '__main__':\n    main()\n","undoManager":{"mark":-1,"position":-1,"stack":[]},"timestamp":1587249685625}