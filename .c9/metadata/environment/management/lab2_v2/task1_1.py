{"changed":true,"filter":false,"title":"task1_1.py","tooltip":"/management/lab2_v2/task1_1.py","value":"import random\nfrom scipy import stats\nimport numpy as np\nfrom queue import Queue, PriorityQueue\nimport matplotlib.pyplot as plt\n\n# ******************************************************************************\n# Constants\n# ******************************************************************************\nNbss = 5\nCAPACITY = 40 #Kwh\nchargerate = 14 #Kwh\nSERVICE = 2 * chargerate  # av service time\nARRIVAL = 2000  # av inter-arrival time\n\nwaitingLine = []\nbatteryInCharge = []\ninter_charge = 7200\nSIM_TIME = 86400*30\nw = 3600  # max waiting client\n\nclass Measure:\n    def __init__(self, Narr, Ndep, Loss, Served, NAveraegUser, OldTimeEvent, AverageDelay, DelayDistr, WaitDel,\n                 NAveraegUserBuff, BusyTime, kWaitDel):\n        self.arr = Narr\n        self.dep = Ndep\n        self.loss = Loss\n        self.served = Served\n        self.ut = NAveraegUser\n        self.oldT = OldTimeEvent\n        self.delay = AverageDelay\n        self.waitDelDistr = []\n        self.lossDistr = []\n        self.waitDel = WaitDel\n        self.utBuffer = NAveraegUserBuff\n        self.busyTime = BusyTime\n        self.KwaitDel = kWaitDel\n        self.k = []\n\n\n# ******************************************************************************\n# Client\n# ******************************************************************************\nclass Client:\n    def __init__(self, arrival_time,Charge):\n        self.arrival_time = arrival_time\n        self.charge = Charge\n\n\n# ******************************************************************************\n# station\n# ******************************************************************************\nclass Station(object):\n\n    # constructor\n    def __init__(self, nReady=Nbss, nCharge=0):\n        self.nReady = nReady\n        self.nCharge = nCharge\n        # whether the station is idle or not\n        # self.idle = True\n\n\n# ******************************************************************************\n\n# arrivals *********************************************************************\ndef arrival(time, FES, queue):\n    # Cumulate statistic\n    data.arr += 1\n\n    # sample the time until the next event\n    inter_arrival = random.expovariate(lambd=1.0 / ARRIVAL)\n    # schedule the next arrival\n    FES.put((time + inter_arrival, \"arrival\"))\n\n    # create a record for the client\n    batteryCharge = (random.randint(0,20)/100)*CAPACITY   #Battery remaining of arriving client\n    print(batteryCharge)\n    client = Client(time,batteryCharge)\n\n    # insert the record in the queue\n    queue.append(client)\n\n    if station.nReady > 0:\n        print(\"Ready: \", station.nReady, \" In charge\", station.nCharge)\n        station.nReady -= 1\n        station.nCharge += 1\n        fullChargeTime = (CAPACITY-batteryCharge)/chargerate *3600\n        data.served += 1\n        data.waitDelDistr.append([time,data.waitDel/data.served])\n        print(fullChargeTime)\n        FES.put((time + fullChargeTime, \"fullcharge\"))\n    else:\n        if len(waitingLine) == Nbss:\n            data.loss += 1\n            data.lossDistr.append([time,data.loss/data.arr])\n            queue.pop()\n            return\n        waitingLine.append([client, time + w])\n\n\n# ******************************************************************************\n\n# fullcharges *******************************************************************\ndef fullcharge(time, FES, queue):\n    # Cumulative statistic\n    data.ut += len(waitingLine) * (time - data.oldT)\n    data.utBuffer += len(waitingLine) * (time - data.oldT)\n    data.oldT = time\n\n    chargeTime = 7200\n    # if no battery in charge return\n    if station.nCharge == 0:\n        return\n    if len(queue) > 0:\n        client = queue.pop(0)\n        data.delay += (time - client.arrival_time)\n        while len(waitingLine) > 0:\n            Customer = waitingLine.pop(0)\n            if time < Customer[1]:\n                data.served += 1\n                data.waitDel += time - (Customer[1]-w)\n                data.waitDelDistr.append([time,data.waitDel/data.served])\n                if data.served > 74:\n                    data.KwaitDel += time - (Customer[1] - w)\n                    print(data.KwaitDel)\n                    data.k.append([time,data.KwaitDel/(data.served-74)])\n                fullChargeTime = (CAPACITY-Customer[0].charge)/chargerate *3600\n                FES.put((time + fullChargeTime,\n                         \"fullcharge\"))  # If not expired serve the customer (give the charged battery and retrieve the uncharged one, total doesn't change)\n                return\n            else:\n                data.loss += 1\n                data.lossDistr.append([time,data.loss/data.arr])\n\n        # If no customer waiting\n        station.nReady += 1\n        station.nCharge -= 1\n        print(\"Ready: \", station.nReady, \" In charge\", station.nCharge)\n\n# ******************************************************************************\n# the \"main\" of the simulation\n# ******************************************************************************\n\nrandom.seed(42)\n\ndata = Measure(0, 0, 0, 0, 0, 0, 0, [], 0, 0, 0, 0)\n\n# the simulation time\ntime = 0\n# the list of events in the form: (time, type)\nFES = PriorityQueue()\nstartFull = 0\nstation = Station(startFull,Nbss-startFull)\nfor i in range (Nbss-startFull):\n    fullChargeTime = (CAPACITY-(random.randint(60,99)/100)*CAPACITY)/chargerate*3600\n    print(fullChargeTime)\n    FES.put((fullChargeTime, \"fullcharge\"))\n\n# schedule the first arrival at t=0\nFES.put((0, \"arrival\"))\n\n# simulate until the simulated time reaches a constant\nwhile time < SIM_TIME:\n    (time, event_type) = FES.get()\n    if event_type == \"arrival\":\n        arrival(time, FES, batteryInCharge)\n\n    elif event_type == \"fullcharge\":\n        fullcharge(time, FES, batteryInCharge)\n    assert station.nReady + station.nCharge == Nbss\n    print(\"Batterie pronte: \",station.nReady)\n\nprint(\"Missing service probability, at the end: \", data.loss / data.arr)\n\nprint(\"\\nAverage number of users: \", data.ut / time)\n\n# Plot distribution\nplt.xlabel(\"Time [seconds]\")\nplt.ylabel(\"Average waiting delay [seconds]\")\nplt.title(\"Average waiting delay\")\nplt.plot([x[0] for x in data.waitDelDistr],[x[1] for x in  data.waitDelDistr], label=\"Average waiting delay\")\nmean = np.mean([x[1] for x in  data.waitDelDistr])\nmy = np.transpose([[mean] * len([x[0] for x in data.waitDelDistr])])\nplt.plot([x[0] for x in data.waitDelDistr], my, label=\"Mean\")\nplt.legend()\nplt.savefig('avDelay_2batt.png')\nplt.show()\n\nxx = []\nyy = []\ndict = {}\nfor elem in data.lossDistr:\n    dict[elem[0]] = elem[1]\nkeys = dict.keys()\nkeys = sorted(keys)\nfor elem in keys:\n    xx.append(elem)\n    yy.append(dict[elem])\nmean = np.mean(yy)\n\nprint('Missed service probability, mean: ',np.mean(yy))\nmy = np.transpose([[mean] * len(xx)])\nplt.plot(xx,yy, label='Missed service probability')\nplt.plot(xx,my, label='Mean value')\nplt.xlabel('Time [second]')\nplt.ylabel('Missed service probability')\nplt.legend(loc=4)\n#plt.savefig('miss_prob_deletek_.png')\nplt.show()\n\n#per eliminare warm-up transient period\nyy = [x[1] for x in  data.waitDelDistr]\nmean = np.mean(yy)\n\nRk = []\nk_vect = []\nmean_vect = []\nfor k in range(0, len(yy)):\n    k_vect.append(k)\n    yy_k = yy[k:]\n    mean_k = np.mean(yy_k)\n    mean_vect.append(mean_k)\n    Rk.append((mean_k-mean)/mean)\nplt.plot(k_vect,Rk)\nplt.xlabel('k')\nplt.ylabel('Rk')\nplt.show()\n\nx_hat = [x[1] for x in data.waitDelDistr]\nm = np.mean(x_hat)\nprint(\"TOTAL mean: \",m)\ns_2 = np.var(x_hat)\ns = np.std(x_hat)\nn = len(x_hat)\nz = ([x-m for x in x_hat])/(s/ np.sqrt(n))\nplt.hist(x_hat,bins=500)\nplt.title(\"Delay distribution\")\nplt.xlabel(\"Delay [seconds]\")\nplt.ylabel(\"Probability\")\nplt.savefig(\"hist_delay.png\")\nplt.show()\nprint(stats.norm.interval(0.9,loc=m,scale=s/np.sqrt(len(x_hat))))\n\nplt.xlabel(\"Time [seconds]\")\nplt.ylabel(\"Average waiting delay [seconds]\")\nplt.title(\"Average waiting delay (k)\")\nplt.plot([x[0] for x in data.k[1:]],[x[1] for x in  data.k[1:]], label=\"Average waiting delay from k\")\nmean = np.mean([x[1] for x in  data.k])\nmy = np.transpose([[mean] * len([x[0] for x in data.k])])\nplt.plot([x[0] for x in data.k], my, label=\"Mean k\")\nplt.plot([x[0] for x in data.waitDelDistr],[x[1] for x in  data.waitDelDistr], label=\"Average waiting delay\")\nmean = np.mean([x[1] for x in  data.waitDelDistr])\nmy = np.transpose([[mean] * len([x[0] for x in data.waitDelDistr])])\nplt.plot([x[0] for x in data.waitDelDistr], my, label=\"Mean\")\nplt.legend()\n#plt.savefig(\"av_cut.png\")\nplt.show()\n\nx_hat = [x[1] for x in data.k]\nm = np.mean(x_hat)\nprint(\"TOTAL mean: \",m)\ns_2 = np.var(x_hat)\ns = np.std(x_hat)\nn = len(x_hat)\nz = ([x-m for x in x_hat])/(s/ np.sqrt(n))\nplt.hist(x_hat,bins=500)\nplt.title(\"Delay distribution\")\nplt.xlabel(\"Delay [seconds]\")\nplt.ylabel(\"Probability\")\nplt.savefig(\"hist_delay_k.png\")\nplt.show()\nprint(stats.norm.interval(0.9,loc=m,scale=s/np.sqrt(len(x_hat))))","undoManager":{"mark":0,"position":1,"stack":[[{"start":{"row":0,"column":0},"end":{"row":274,"column":65},"action":"insert","lines":["import random","from scipy import stats","import numpy as np","from queue import Queue, PriorityQueue","import matplotlib.pyplot as plt","","# ******************************************************************************","# Constants","# ******************************************************************************","Nbss = 5","CAPACITY = 40 #Kwh","chargerate = 12 #Kwh","# ARRIVAL = 100","SERVICE = 2 * chargerate  # av service time","","ARRIVAL = 1800  # av inter-arrival time","","waitingLine = []","batteryInCharge = []","inter_charge = 7200","SIM_TIME = 86400*100","w = 2000  # max waiting client","","","class Measure:","    def __init__(self, Narr, Ndep, Loss, Served, NAveraegUser, OldTimeEvent, AverageDelay, DelayDistr, WaitDel,","                 NAveraegUserBuff, BusyTime):","        self.arr = Narr","        self.dep = Ndep","        self.loss = Loss","        self.served = Served","        self.ut = NAveraegUser","        self.oldT = OldTimeEvent","        self.delay = AverageDelay","        self.waitDelDistr = []","        self.lossDistr = []","        self.waitDel = WaitDel","        self.utBuffer = NAveraegUserBuff","        self.busyTime = BusyTime","","","# ******************************************************************************","# Client","# ******************************************************************************","class Client:","    def __init__(self, arrival_time,Charge):","        self.arrival_time = arrival_time","        self.charge = Charge","","","# ******************************************************************************","# station","# ******************************************************************************","class Station(object):","","    # constructor","    def __init__(self, nReady=Nbss, nCharge=0):","        self.nReady = nReady","        self.nCharge = nCharge","        # whether the station is idle or not","        # self.idle = True","","","# ******************************************************************************","","# arrivals *********************************************************************","def arrival(time, FES, queue):","    # Cumulate statistic","    data.arr += 1","","    # sample the time until the next event","    inter_arrival = random.expovariate(lambd=1.0 / ARRIVAL)","    # schedule the next arrival","    FES.put((time + inter_arrival, \"arrival\"))","","    # create a record for the client","    batteryCharge = (random.randint(0,20)/100)*CAPACITY   #Battery remaining of arriving client","    print(batteryCharge)","    client = Client(time,batteryCharge)","","    # insert the record in the queue","    queue.append(client)","","    if station.nReady > 0:","        print(\"Ready: \", station.nReady, \" In charge\", station.nCharge)","        station.nReady -= 1","        station.nCharge += 1","        fullChargeTime = (CAPACITY-batteryCharge)/chargerate *3600","        data.served += 1","        #data.waitDelDistr.append(0)","        data.waitDelDistr.append([time,data.waitDel/data.served])","        print(fullChargeTime)","        FES.put((time + fullChargeTime, \"fullcharge\"))","    else:","        if len(waitingLine) == Nbss:  # Se ho già un attesa per ogni batteria","            data.loss += 1","            data.lossDistr.append([time,data.loss/data.arr])","            queue.pop()","            return","        waitingLine.append([client, time + w])  # entra in coda e aspetta al massimo w","","","# ******************************************************************************","","# fullcharges *******************************************************************","def fullcharge(time, FES, queue):","    # Cumulative statistic","    data.ut += len(waitingLine) * (time - data.oldT)","    data.utBuffer += len(waitingLine) * (time - data.oldT)","    data.oldT = time","","    #chargeTime = random.expovariate(1.0 / SERVICE)","    chargeTime = 7200","    # if no battery in charge return","    if station.nCharge == 0:","        return","    if len(queue) > 0:","        client = queue.pop(0)","        data.delay += (time - client.arrival_time) # BATTERIE","        # chargeTime = inter_charge","        while len(waitingLine) > 0:","            Customer = waitingLine.pop(0)","            #print(time - Customer[1])","            #data.waitDelDistr.append(time - (Customer[1]-w))","            if time < Customer[1]: #se il cliente in attesa non ha ancora raggiunto il suo massimo","                #time (=arrivo+carica) < Customer[1] (=arrivo+maxWait) -> carica<maxWait","                data.served += 1","                data.waitDel += time - (Customer[1]-w)","                data.waitDelDistr.append([time,data.waitDel/data.served])","                # data.waitDelDistr.append([time - (Customer[1]-w), len(waitingLine)])","                fullChargeTime = (CAPACITY-Customer[0].charge)/chargerate *3600","                FES.put((time + fullChargeTime,","                         \"fullcharge\"))  # If not expired serve the customer (give the charged battery and retrieve the uncharged one, total doesn't change)","                return","            else:","                data.loss += 1","                data.lossDistr.append([time,data.loss/data.arr])","","        # If no customer waiting","        station.nReady += 1","        station.nCharge -= 1","        print(\"Ready: \", station.nReady, \" In charge\", station.nCharge)","","# ******************************************************************************","# the \"main\" of the simulation","# ******************************************************************************","","random.seed(42)","","data = Measure(0, 0, 0, 0, 0, 0, 0, [], 0, 0, 0)","","# the simulation time","time = 0","# lost client","# loss = 0","# the list of events in the form: (time, type)","FES = PriorityQueue()","","station = Station()","# schedule the first arrival at t=0","FES.put((0, \"arrival\"))","","# simulate until the simulated time reaches a constant","while time < SIM_TIME:","    (time, event_type) = FES.get()","    if event_type == \"arrival\":","        arrival(time, FES, batteryInCharge)","","    elif event_type == \"fullcharge\":","        fullcharge(time, FES, batteryInCharge)","    assert station.nReady + station.nCharge == Nbss","    print(\"Batterie pronte: \",station.nReady)","","print(\"Missing service probability, at the end: \", data.loss / data.arr)","","# print output data","# print(\"MEASUREMENTS \\n\\nNo. of users in the queue:\",users,\"\\nNo. of arrivals =\",","# data.arr,\"- No. of fullcharges =\",data.dep)","","# print(\"Load: \",SERVICE/ARRIVAL)","# print(\"\\nArrival rate: \",data.arr/time,\" - fullcharge rate: \",data.dep/time)","","print(\"\\nAverage number of users: \", data.ut / time)","","# print(\"Average delay: \",data.delay/data.dep)","# print(\"Actual queue size: \",len(MM1))","","# print(\"Average waiting in queue: \", data.waitDel/data.dep)","# print(\"Average waiting in queue of packets in queue: \",data.waitDel/countQ)","# print(\"Average number of user in queue: \", data.utBuffer/time)","# print(\"Busy time station: \", data.busyTime)","# Plot distribution","plt.xlabel(\"Time\")","plt.ylabel(\"Average waiting delay\")","plt.title(\"Average waiting delay\")","plt.plot([x[0] for x in data.waitDelDistr],[x[1] for x in  data.waitDelDistr], label=\"Average waiting delay\")","mean = np.mean([x[1] for x in  data.waitDelDistr])","my = np.transpose([[mean] * len([x[0] for x in data.waitDelDistr])])","plt.plot([x[0] for x in data.waitDelDistr], my, label=\"Mean\")","","plt.show()","","","xx = []","yy = []","dict = {}","for elem in data.lossDistr:","    #xx.append(elem[0])","    #yy.append(elem[1])","    dict[elem[0]] = elem[1]","keys = dict.keys()","keys = sorted(keys)","for elem in keys:","    xx.append(elem)","    yy.append(dict[elem])","mean = np.mean(yy)","","print('Missed service probability, mean: ',np.mean(yy))","my = np.transpose([[mean] * len(xx)])","plt.plot(xx,yy, label='Missed service probability')","plt.plot(xx,my, label='Mean value')","# plt.hist(x,bins=100)    # It's an exponential","plt.xlabel('Time [second]')","plt.ylabel('Missed service probability')","plt.legend(loc=4)","plt.savefig('miss_prob_deletek_.png')","plt.show()","","# print('len di yy', len(yy))","#per eliminare warm-up transient period","yy = [x[1] for x in  data.waitDelDistr]","mean = np.mean(yy)","","","Rk = []","k_vect = []","for k in range(0, len(yy)):","    k_vect.append(k)","    yy_k = yy[k:]","    mean_k = np.mean(yy_k)","    Rk.append((mean_k-mean)/mean)","plt.plot(k_vect,Rk)","plt.xlabel('k')","plt.ylabel('Rk')","plt.show()","","# stable = 0","# i = 0","# j = i","# while i < len(yy) and stable < 5:","    # for i in range (0,len(yy)):","        # print(yy[i])","        # if yy[i]>(mean-0.01) and yy[i]<(mean+0.01):","            # stable +=1","            # print('arrivo ad un valore vicino alla media dopo elemento: ', i)","        # i += 1","","#run con Nbss = 2","#Missed service probability, mean:  0.7969604212721231","#run con Nbss = 5","#Missed service probability, mean:  0.5373317032887762","##run con Nbss = 10","#Missed service probability, mean:  0.19448167396906266","","# test = data.waitDelDistr[100:]","x_hat = [x[1] for x in data.waitDelDistr]","m = np.mean(x_hat)","print(\"TOTAL mean: \",m)","s_2 = np.var(x_hat)","s = np.std(x_hat)","n = len(x_hat)","z = ([x-m for x in x_hat])/(s/ np.sqrt(n))","plt.hist(x_hat,bins=500)","plt.show()","print(stats.norm.interval(0.9,loc=m,scale=s/np.sqrt(len(x_hat))))"],"id":1}],[{"start":{"row":0,"column":0},"end":{"row":274,"column":65},"action":"remove","lines":["import random","from scipy import stats","import numpy as np","from queue import Queue, PriorityQueue","import matplotlib.pyplot as plt","","# ******************************************************************************","# Constants","# ******************************************************************************","Nbss = 5","CAPACITY = 40 #Kwh","chargerate = 12 #Kwh","# ARRIVAL = 100","SERVICE = 2 * chargerate  # av service time","","ARRIVAL = 1800  # av inter-arrival time","","waitingLine = []","batteryInCharge = []","inter_charge = 7200","SIM_TIME = 86400*100","w = 2000  # max waiting client","","","class Measure:","    def __init__(self, Narr, Ndep, Loss, Served, NAveraegUser, OldTimeEvent, AverageDelay, DelayDistr, WaitDel,","                 NAveraegUserBuff, BusyTime):","        self.arr = Narr","        self.dep = Ndep","        self.loss = Loss","        self.served = Served","        self.ut = NAveraegUser","        self.oldT = OldTimeEvent","        self.delay = AverageDelay","        self.waitDelDistr = []","        self.lossDistr = []","        self.waitDel = WaitDel","        self.utBuffer = NAveraegUserBuff","        self.busyTime = BusyTime","","","# ******************************************************************************","# Client","# ******************************************************************************","class Client:","    def __init__(self, arrival_time,Charge):","        self.arrival_time = arrival_time","        self.charge = Charge","","","# ******************************************************************************","# station","# ******************************************************************************","class Station(object):","","    # constructor","    def __init__(self, nReady=Nbss, nCharge=0):","        self.nReady = nReady","        self.nCharge = nCharge","        # whether the station is idle or not","        # self.idle = True","","","# ******************************************************************************","","# arrivals *********************************************************************","def arrival(time, FES, queue):","    # Cumulate statistic","    data.arr += 1","","    # sample the time until the next event","    inter_arrival = random.expovariate(lambd=1.0 / ARRIVAL)","    # schedule the next arrival","    FES.put((time + inter_arrival, \"arrival\"))","","    # create a record for the client","    batteryCharge = (random.randint(0,20)/100)*CAPACITY   #Battery remaining of arriving client","    print(batteryCharge)","    client = Client(time,batteryCharge)","","    # insert the record in the queue","    queue.append(client)","","    if station.nReady > 0:","        print(\"Ready: \", station.nReady, \" In charge\", station.nCharge)","        station.nReady -= 1","        station.nCharge += 1","        fullChargeTime = (CAPACITY-batteryCharge)/chargerate *3600","        data.served += 1","        #data.waitDelDistr.append(0)","        data.waitDelDistr.append([time,data.waitDel/data.served])","        print(fullChargeTime)","        FES.put((time + fullChargeTime, \"fullcharge\"))","    else:","        if len(waitingLine) == Nbss:  # Se ho già un attesa per ogni batteria","            data.loss += 1","            data.lossDistr.append([time,data.loss/data.arr])","            queue.pop()","            return","        waitingLine.append([client, time + w])  # entra in coda e aspetta al massimo w","","","# ******************************************************************************","","# fullcharges *******************************************************************","def fullcharge(time, FES, queue):","    # Cumulative statistic","    data.ut += len(waitingLine) * (time - data.oldT)","    data.utBuffer += len(waitingLine) * (time - data.oldT)","    data.oldT = time","","    #chargeTime = random.expovariate(1.0 / SERVICE)","    chargeTime = 7200","    # if no battery in charge return","    if station.nCharge == 0:","        return","    if len(queue) > 0:","        client = queue.pop(0)","        data.delay += (time - client.arrival_time) # BATTERIE","        # chargeTime = inter_charge","        while len(waitingLine) > 0:","            Customer = waitingLine.pop(0)","            #print(time - Customer[1])","            #data.waitDelDistr.append(time - (Customer[1]-w))","            if time < Customer[1]: #se il cliente in attesa non ha ancora raggiunto il suo massimo","                #time (=arrivo+carica) < Customer[1] (=arrivo+maxWait) -> carica<maxWait","                data.served += 1","                data.waitDel += time - (Customer[1]-w)","                data.waitDelDistr.append([time,data.waitDel/data.served])","                # data.waitDelDistr.append([time - (Customer[1]-w), len(waitingLine)])","                fullChargeTime = (CAPACITY-Customer[0].charge)/chargerate *3600","                FES.put((time + fullChargeTime,","                         \"fullcharge\"))  # If not expired serve the customer (give the charged battery and retrieve the uncharged one, total doesn't change)","                return","            else:","                data.loss += 1","                data.lossDistr.append([time,data.loss/data.arr])","","        # If no customer waiting","        station.nReady += 1","        station.nCharge -= 1","        print(\"Ready: \", station.nReady, \" In charge\", station.nCharge)","","# ******************************************************************************","# the \"main\" of the simulation","# ******************************************************************************","","random.seed(42)","","data = Measure(0, 0, 0, 0, 0, 0, 0, [], 0, 0, 0)","","# the simulation time","time = 0","# lost client","# loss = 0","# the list of events in the form: (time, type)","FES = PriorityQueue()","","station = Station()","# schedule the first arrival at t=0","FES.put((0, \"arrival\"))","","# simulate until the simulated time reaches a constant","while time < SIM_TIME:","    (time, event_type) = FES.get()","    if event_type == \"arrival\":","        arrival(time, FES, batteryInCharge)","","    elif event_type == \"fullcharge\":","        fullcharge(time, FES, batteryInCharge)","    assert station.nReady + station.nCharge == Nbss","    print(\"Batterie pronte: \",station.nReady)","","print(\"Missing service probability, at the end: \", data.loss / data.arr)","","# print output data","# print(\"MEASUREMENTS \\n\\nNo. of users in the queue:\",users,\"\\nNo. of arrivals =\",","# data.arr,\"- No. of fullcharges =\",data.dep)","","# print(\"Load: \",SERVICE/ARRIVAL)","# print(\"\\nArrival rate: \",data.arr/time,\" - fullcharge rate: \",data.dep/time)","","print(\"\\nAverage number of users: \", data.ut / time)","","# print(\"Average delay: \",data.delay/data.dep)","# print(\"Actual queue size: \",len(MM1))","","# print(\"Average waiting in queue: \", data.waitDel/data.dep)","# print(\"Average waiting in queue of packets in queue: \",data.waitDel/countQ)","# print(\"Average number of user in queue: \", data.utBuffer/time)","# print(\"Busy time station: \", data.busyTime)","# Plot distribution","plt.xlabel(\"Time\")","plt.ylabel(\"Average waiting delay\")","plt.title(\"Average waiting delay\")","plt.plot([x[0] for x in data.waitDelDistr],[x[1] for x in  data.waitDelDistr], label=\"Average waiting delay\")","mean = np.mean([x[1] for x in  data.waitDelDistr])","my = np.transpose([[mean] * len([x[0] for x in data.waitDelDistr])])","plt.plot([x[0] for x in data.waitDelDistr], my, label=\"Mean\")","","plt.show()","","","xx = []","yy = []","dict = {}","for elem in data.lossDistr:","    #xx.append(elem[0])","    #yy.append(elem[1])","    dict[elem[0]] = elem[1]","keys = dict.keys()","keys = sorted(keys)","for elem in keys:","    xx.append(elem)","    yy.append(dict[elem])","mean = np.mean(yy)","","print('Missed service probability, mean: ',np.mean(yy))","my = np.transpose([[mean] * len(xx)])","plt.plot(xx,yy, label='Missed service probability')","plt.plot(xx,my, label='Mean value')","# plt.hist(x,bins=100)    # It's an exponential","plt.xlabel('Time [second]')","plt.ylabel('Missed service probability')","plt.legend(loc=4)","plt.savefig('miss_prob_deletek_.png')","plt.show()","","# print('len di yy', len(yy))","#per eliminare warm-up transient period","yy = [x[1] for x in  data.waitDelDistr]","mean = np.mean(yy)","","","Rk = []","k_vect = []","for k in range(0, len(yy)):","    k_vect.append(k)","    yy_k = yy[k:]","    mean_k = np.mean(yy_k)","    Rk.append((mean_k-mean)/mean)","plt.plot(k_vect,Rk)","plt.xlabel('k')","plt.ylabel('Rk')","plt.show()","","# stable = 0","# i = 0","# j = i","# while i < len(yy) and stable < 5:","    # for i in range (0,len(yy)):","        # print(yy[i])","        # if yy[i]>(mean-0.01) and yy[i]<(mean+0.01):","            # stable +=1","            # print('arrivo ad un valore vicino alla media dopo elemento: ', i)","        # i += 1","","#run con Nbss = 2","#Missed service probability, mean:  0.7969604212721231","#run con Nbss = 5","#Missed service probability, mean:  0.5373317032887762","##run con Nbss = 10","#Missed service probability, mean:  0.19448167396906266","","# test = data.waitDelDistr[100:]","x_hat = [x[1] for x in data.waitDelDistr]","m = np.mean(x_hat)","print(\"TOTAL mean: \",m)","s_2 = np.var(x_hat)","s = np.std(x_hat)","n = len(x_hat)","z = ([x-m for x in x_hat])/(s/ np.sqrt(n))","plt.hist(x_hat,bins=500)","plt.show()","print(stats.norm.interval(0.9,loc=m,scale=s/np.sqrt(len(x_hat))))"],"id":2},{"start":{"row":0,"column":0},"end":{"row":271,"column":65},"action":"insert","lines":["import random","from scipy import stats","import numpy as np","from queue import Queue, PriorityQueue","import matplotlib.pyplot as plt","","# ******************************************************************************","# Constants","# ******************************************************************************","Nbss = 5","CAPACITY = 40 #Kwh","chargerate = 14 #Kwh","SERVICE = 2 * chargerate  # av service time","ARRIVAL = 2000  # av inter-arrival time","","waitingLine = []","batteryInCharge = []","inter_charge = 7200","SIM_TIME = 86400*30","w = 3600  # max waiting client","","class Measure:","    def __init__(self, Narr, Ndep, Loss, Served, NAveraegUser, OldTimeEvent, AverageDelay, DelayDistr, WaitDel,","                 NAveraegUserBuff, BusyTime, kWaitDel):","        self.arr = Narr","        self.dep = Ndep","        self.loss = Loss","        self.served = Served","        self.ut = NAveraegUser","        self.oldT = OldTimeEvent","        self.delay = AverageDelay","        self.waitDelDistr = []","        self.lossDistr = []","        self.waitDel = WaitDel","        self.utBuffer = NAveraegUserBuff","        self.busyTime = BusyTime","        self.KwaitDel = kWaitDel","        self.k = []","","","# ******************************************************************************","# Client","# ******************************************************************************","class Client:","    def __init__(self, arrival_time,Charge):","        self.arrival_time = arrival_time","        self.charge = Charge","","","# ******************************************************************************","# station","# ******************************************************************************","class Station(object):","","    # constructor","    def __init__(self, nReady=Nbss, nCharge=0):","        self.nReady = nReady","        self.nCharge = nCharge","        # whether the station is idle or not","        # self.idle = True","","","# ******************************************************************************","","# arrivals *********************************************************************","def arrival(time, FES, queue):","    # Cumulate statistic","    data.arr += 1","","    # sample the time until the next event","    inter_arrival = random.expovariate(lambd=1.0 / ARRIVAL)","    # schedule the next arrival","    FES.put((time + inter_arrival, \"arrival\"))","","    # create a record for the client","    batteryCharge = (random.randint(0,20)/100)*CAPACITY   #Battery remaining of arriving client","    print(batteryCharge)","    client = Client(time,batteryCharge)","","    # insert the record in the queue","    queue.append(client)","","    if station.nReady > 0:","        print(\"Ready: \", station.nReady, \" In charge\", station.nCharge)","        station.nReady -= 1","        station.nCharge += 1","        fullChargeTime = (CAPACITY-batteryCharge)/chargerate *3600","        data.served += 1","        data.waitDelDistr.append([time,data.waitDel/data.served])","        print(fullChargeTime)","        FES.put((time + fullChargeTime, \"fullcharge\"))","    else:","        if len(waitingLine) == Nbss:","            data.loss += 1","            data.lossDistr.append([time,data.loss/data.arr])","            queue.pop()","            return","        waitingLine.append([client, time + w])","","","# ******************************************************************************","","# fullcharges *******************************************************************","def fullcharge(time, FES, queue):","    # Cumulative statistic","    data.ut += len(waitingLine) * (time - data.oldT)","    data.utBuffer += len(waitingLine) * (time - data.oldT)","    data.oldT = time","","    chargeTime = 7200","    # if no battery in charge return","    if station.nCharge == 0:","        return","    if len(queue) > 0:","        client = queue.pop(0)","        data.delay += (time - client.arrival_time)","        while len(waitingLine) > 0:","            Customer = waitingLine.pop(0)","            if time < Customer[1]:","                data.served += 1","                data.waitDel += time - (Customer[1]-w)","                data.waitDelDistr.append([time,data.waitDel/data.served])","                if data.served > 74:","                    data.KwaitDel += time - (Customer[1] - w)","                    print(data.KwaitDel)","                    data.k.append([time,data.KwaitDel/(data.served-74)])","                fullChargeTime = (CAPACITY-Customer[0].charge)/chargerate *3600","                FES.put((time + fullChargeTime,","                         \"fullcharge\"))  # If not expired serve the customer (give the charged battery and retrieve the uncharged one, total doesn't change)","                return","            else:","                data.loss += 1","                data.lossDistr.append([time,data.loss/data.arr])","","        # If no customer waiting","        station.nReady += 1","        station.nCharge -= 1","        print(\"Ready: \", station.nReady, \" In charge\", station.nCharge)","","# ******************************************************************************","# the \"main\" of the simulation","# ******************************************************************************","","random.seed(42)","","data = Measure(0, 0, 0, 0, 0, 0, 0, [], 0, 0, 0, 0)","","# the simulation time","time = 0","# the list of events in the form: (time, type)","FES = PriorityQueue()","startFull = 0","station = Station(startFull,Nbss-startFull)","for i in range (Nbss-startFull):","    fullChargeTime = (CAPACITY-(random.randint(60,99)/100)*CAPACITY)/chargerate*3600","    print(fullChargeTime)","    FES.put((fullChargeTime, \"fullcharge\"))","","# schedule the first arrival at t=0","FES.put((0, \"arrival\"))","","# simulate until the simulated time reaches a constant","while time < SIM_TIME:","    (time, event_type) = FES.get()","    if event_type == \"arrival\":","        arrival(time, FES, batteryInCharge)","","    elif event_type == \"fullcharge\":","        fullcharge(time, FES, batteryInCharge)","    assert station.nReady + station.nCharge == Nbss","    print(\"Batterie pronte: \",station.nReady)","","print(\"Missing service probability, at the end: \", data.loss / data.arr)","","print(\"\\nAverage number of users: \", data.ut / time)","","# Plot distribution","plt.xlabel(\"Time [seconds]\")","plt.ylabel(\"Average waiting delay [seconds]\")","plt.title(\"Average waiting delay\")","plt.plot([x[0] for x in data.waitDelDistr],[x[1] for x in  data.waitDelDistr], label=\"Average waiting delay\")","mean = np.mean([x[1] for x in  data.waitDelDistr])","my = np.transpose([[mean] * len([x[0] for x in data.waitDelDistr])])","plt.plot([x[0] for x in data.waitDelDistr], my, label=\"Mean\")","plt.legend()","plt.savefig('avDelay_2batt.png')","plt.show()","","xx = []","yy = []","dict = {}","for elem in data.lossDistr:","    dict[elem[0]] = elem[1]","keys = dict.keys()","keys = sorted(keys)","for elem in keys:","    xx.append(elem)","    yy.append(dict[elem])","mean = np.mean(yy)","","print('Missed service probability, mean: ',np.mean(yy))","my = np.transpose([[mean] * len(xx)])","plt.plot(xx,yy, label='Missed service probability')","plt.plot(xx,my, label='Mean value')","plt.xlabel('Time [second]')","plt.ylabel('Missed service probability')","plt.legend(loc=4)","#plt.savefig('miss_prob_deletek_.png')","plt.show()","","#per eliminare warm-up transient period","yy = [x[1] for x in  data.waitDelDistr]","mean = np.mean(yy)","","Rk = []","k_vect = []","mean_vect = []","for k in range(0, len(yy)):","    k_vect.append(k)","    yy_k = yy[k:]","    mean_k = np.mean(yy_k)","    mean_vect.append(mean_k)","    Rk.append((mean_k-mean)/mean)","plt.plot(k_vect,Rk)","plt.xlabel('k')","plt.ylabel('Rk')","plt.show()","","x_hat = [x[1] for x in data.waitDelDistr]","m = np.mean(x_hat)","print(\"TOTAL mean: \",m)","s_2 = np.var(x_hat)","s = np.std(x_hat)","n = len(x_hat)","z = ([x-m for x in x_hat])/(s/ np.sqrt(n))","plt.hist(x_hat,bins=500)","plt.title(\"Delay distribution\")","plt.xlabel(\"Delay [seconds]\")","plt.ylabel(\"Probability\")","plt.savefig(\"hist_delay.png\")","plt.show()","print(stats.norm.interval(0.9,loc=m,scale=s/np.sqrt(len(x_hat))))","","plt.xlabel(\"Time [seconds]\")","plt.ylabel(\"Average waiting delay [seconds]\")","plt.title(\"Average waiting delay (k)\")","plt.plot([x[0] for x in data.k[1:]],[x[1] for x in  data.k[1:]], label=\"Average waiting delay from k\")","mean = np.mean([x[1] for x in  data.k])","my = np.transpose([[mean] * len([x[0] for x in data.k])])","plt.plot([x[0] for x in data.k], my, label=\"Mean k\")","plt.plot([x[0] for x in data.waitDelDistr],[x[1] for x in  data.waitDelDistr], label=\"Average waiting delay\")","mean = np.mean([x[1] for x in  data.waitDelDistr])","my = np.transpose([[mean] * len([x[0] for x in data.waitDelDistr])])","plt.plot([x[0] for x in data.waitDelDistr], my, label=\"Mean\")","plt.legend()","#plt.savefig(\"av_cut.png\")","plt.show()","","x_hat = [x[1] for x in data.k]","m = np.mean(x_hat)","print(\"TOTAL mean: \",m)","s_2 = np.var(x_hat)","s = np.std(x_hat)","n = len(x_hat)","z = ([x-m for x in x_hat])/(s/ np.sqrt(n))","plt.hist(x_hat,bins=500)","plt.title(\"Delay distribution\")","plt.xlabel(\"Delay [seconds]\")","plt.ylabel(\"Probability\")","plt.savefig(\"hist_delay_k.png\")","plt.show()","print(stats.norm.interval(0.9,loc=m,scale=s/np.sqrt(len(x_hat))))"]}]]},"ace":{"folds":[],"scrolltop":3704,"scrollleft":0,"selection":{"start":{"row":264,"column":38},"end":{"row":264,"column":38},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":245,"state":"start","mode":"ace/mode/python"}},"timestamp":1595431222912}